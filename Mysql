1、常用设计模式
    目的是为了让代码有更好的重用性、可读性、可靠性以及维护性，可扩展（增加新功能不用修改接口）
    六大原则：开放封闭、里氏替换、依赖倒置、单一职责、接口隔离、迪米特
    1.单例模式：在应用程序中最多只有该类一个的一个实例存在，创建后就会一直存在于内存中。只能由类本身实例化，构造函数必须标记为私有的，也需要一个私有的静态成员变量来保存类的实例和一个公开的能访问到示例的静态方法。
        经常用来做数据库连接、只连接一次数据库，防止打开多个数据库连接。
    2.工厂设计模式:是用工厂方法来代替new操作的一种模式
    建立一个工厂类，用来处理其他的实例对象
    3.观察者设计模式：是定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所以依赖于它的对象都能得到通知并自动刷新，符合接口隔离原则
    使用场景：用户登录，需要写日志，送积分，参与活动 等， 使用消息队列，把用户和日志，积分，活动之间解耦合
    4.适配器模式：这种模式使得原本的由于接口不兼容不能一起工作的那些类可以一起工作
    应用场景：老代码接口不适应新的接口需求，或者代码很多很乱不便于继续修改，或者使用第三方类库。例如：php连接数据库的方法：mysql,,mysqli,pdo,可以用适配器统一

    5.策略模式：将一组特定的行为和算法封装成类
场景：一个电商网站系统，针对男性女性用户要各自跳转到不同的商品类目，并且所有广告位展示不同的广告
2、面向对象：将现实的事物抽象出来，通过继承、实现、组合的方式处理。这种编码方式可以大大降低系统的耦合性，提高系统维护性，它是模型化的，只需抽象出一个类，类里面有解决问题的方法，需要什么直接使用就行了，它的底层其实还是面向过程，把面向过程抽象成类，然后封装，就是面向对象了。
    特性：
        封装：隐藏对象的属性和实现细节、仅对外提供公共访问方式、便于使用、提高复用性和安全性
        继承：提高代码的复用性，是多态的前提
        多态：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高程序的拓展性
3、tp6框架运行流程（生命周期）大致流程
    1、应用入口文件
    2、注册自动加载文件
    3、实例化系统应用基础类think\App
    4、执行Http的run方法
    4.1、获取当前请求对象实例保存在容器。
    4.2、初始化HTTP应用
    4.3、监听AppInit（应用初始化）事件
    4.4、监听HttpRun事件
    4.5、监听RouteLoaded事件
    4.6、监听HttpEnd事件
4、防止表单重复提交
    1）禁掉提交按钮
    2）Post/Redirect/Get 模式，在提交后执行页面重定向
    3）在数据库里添加约束。在数据库里添加唯一约束或创建唯一索引，防止出现重复数据。这是最有效的防止重复提交数据的方法
5、session与cookie的区别
    cookie数据存放在客户的浏览器上，session数据放在服务器上
    Session占用服务器性能，Session过多，增加服务器压力
    单个Cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个Cookie，Session是没有大小限制和服务器的内存大小有关
    Session比Cookie更具有安全性
    【cookie的path 路径设置
        Cookie的path是干什么的呢？假设你的浏览器当前已经有了两个Cookie：
    c1：name=id; value=itcast; path=/day07_03/；
    c2：name=name; value=qdmmy6; path=/day07_03/servlet/。
    当访问http://localhost/day07_03/*时，请求头中会包含c1，而不会包含c2。
    当访问http://localhost/day07_03/servlet/*时，请求头中会包含c1和c2。
    也就是说，在访问子路径时，会包含其父路径的Cookie，而在访问父路径时，不包含子路径的Cookie
    】
    

集群间session共享：
    1、客户端coolie保存
    2、服务器间session同步
    3、session持久化到数据库

6、get与post
    GET 一般用来从服务器上获取资源，POST 一般用来创建资源
    get传值是在url中的，是可见的，post传值是在body体的，是不可见的
    post比get安全
    get请求参数会被完整保留在浏览器历史记录里，而post中的参数不会被保留
    get传输数据量比较小，post比较大【get一般传输数据大小不超过2k-4k，post 请求传输数据的大小根据php.ini 配置文件设定，也可以无限大】
    get产生一个TCP数据包，POST产生两个TCP数据包（get请求时将header和data一起发送 post是先发送header再发送data）
7、http请求方法   
    HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。
    HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法
    
7、M方法和D方法的区别
    都用于实例化一个模型类，M方法用于高效实例化一个基础模型类，而 D方法 用于实例化一个用户定义模型类
    M：对数据表进行简单的 CURD 操作而无复杂的业务逻辑时
    D：需要使用 ThinkPHP 模型中一些高级功能如自动验证功能（create()方法中实现）、关联模型等、业务逻辑比较复杂，且涉及的表众多
8、Composer
    PHP的包管理、包依赖关系管理工具
    可以安装tp框架、laravel框架、
9、PHP运行模式
    CGI：CGI 即通用网关接口（Common Gateway Interface），它是一段程序，通俗的讲 CGI 就象是一座桥，把网页和 Web 服务器中的执行程序连接起来，它把 HTML 接收的指令传递给服务器的执行程序，再把服务器执行程序的结果返还给 HTML 页。CGI 的跨平台性能极佳，几乎可以在任何操作系统上实现

    FastCGI: FastCGI 是 CGI 的升级版本，FastCGI 像是一个常驻 (long-live) 型的 CGI，在启动 web 服务器的时候载入 FastCGI 进程管理器

CLI（命令行运行 / Command Line Interface）
10、include和require的区别
    1）Php在遇到include 时就解释一次，如果页面中出现 10次include ，php就解释 10次，而php 遇到require时只解释一次，即使页面出现多次require也只解释一次，因此require的执行效率比 include高。
    2）Php使用require 包含文件时将被包含的文件当成当前文件的一个组成部分，如果被包含的文件中有语法错误或者被包含的文件不存在，则 php脚本将不再执行，并提示错误。
    3）Php使用include 包含文件时相当于指定了这个文件的路径，当被包含的文件有语法错误或者被包含的文件不存在时给出警告，不影响本身脚本的运行。
    4）Include在包含文件时可以判断文件是否包含，而 require则不管任何情况都包含进来。
    5）Require的效率比require_once的效率更高，因为require_once在包含文件时要进行判断文件是否已经被包含。
11、PHP的垃圾回收机制
    php5：PHP可以自动进行垃圾回收，清除不需要的对象。使用的是引用计数的方法，每个对象都包含有一个引用计数器，当引用连接到对象，计数器+1，当引用离开生命空间或被设为null时，计数器减-，当某个对象的引用计数器为0时，释放所占的空间
    php7：
        标量类型不再计数，不需要单独分配内存
        php的zval需要的内存不再是从堆上分配、不再自己存储引用计数
        php7的复杂数据类型由自身来存储
12、跨域（浏览器的同源策略）
    是指当一个请求url的协议、端口、域名三者任意一个与当前页面url不同即为跨域
    jsonp：包含两部分，回调函数和数据
    

<script>标签不受浏览器同源策略的影响,允许跨域引用资源。因此可以通过动态创建script标签,然后利用src属性进行跨域

    nginx反向代理
    vue代理配置
  CORS 是跨域资源分享：使用自定义的HTTP头部让浏览器与服务器进行沟通

13、self 和 static的区别
    self：调用当前类
    static：  允许函数调用在运行时绑定调用类(calling class)中的方法
14、PHP7新特性
    增加标量类型声明、返回值类型声明、use批量声明、define可以定义常量数组
15、为什么使用微服务
    可以独立开发和部署
    提高代码开发速度
    代码质量将会更高
    更容易扩展




